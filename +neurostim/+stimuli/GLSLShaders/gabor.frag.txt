/*
 * File: BasicGaborShader.frag.txt
 * Shader for drawing of xyL Gabor patches.
 * Adapted from PTB.
 * BK  April 2014
 */

varying float orientation;
varying float contrast;
varying float phase;
varying float freqTwoPi;
varying float expMultiplier;
varying vec4  color; 
varying float meanLuminance; 
varying float sigma1;
varying float sigma2;

uniform int rgbColor;
uniform int mask;

void main()
{
    /* Query current output texel position wrt. to Center of Gabor: */
    vec2 pos = gl_TexCoord[0].xy;

    /* Compute (x,y) distance weighting coefficients, based on rotation angle: */
    /* Note that this is a constant for all fragments, but we can not do it in */
    /* the vertex shader, because the vertex shader does not have sufficient   */
    /* numeric precision on some common hardware out there. */
    vec2 coeff = vec2(cos(orientation), sin(orientation)) * freqTwoPi;

    /* Evaluate sine grating at requested position, angle and phase: */
    float sv = sin(dot(coeff, pos) + phase);

    /* Compute exponential hull for the gabor: */
    float ev;float alpha;
    if (mask==1){
        /* Gabor mask : Sigma = [stdev */
        ev = exp(-0.5 *dot(pos, pos) / (sigma1 * sigma1));
        alpha =1.0;
    }else if (mask==2){
        /* Hard circular mask: sigmae = outer*/
        ev  = float(sqrt(dot(pos,pos))<=sigma1); 
        alpha = ev; /* This makes the part of the texture outside the circle completely transparent */
    }else if (mask==3){
        /* Annulus  Sigma  = [inner outer]*/
        float tmp;
        tmp = sqrt(dot(pos,pos));
        ev  = float((tmp>=sigma1) && (tmp<=sigma2)); 
        alpha = ev; /* This makes the part of the texture outside the circle completely transparent */        
    }else{
        /* Throw an error; this is not a valid mask... */
        ev =1.0;
        alpha = 1.0;
    }

  
    float factor;
    factor =  1.0 +contrast * ev * sv;
    if (rgbColor==1){
        gl_FragColor[0] = color[0] * factor;
        gl_FragColor[1] = color[1] * factor;
        gl_FragColor[2] = color[2] * factor;
        gl_FragColor[3] = alpha*color[3];
    }else{
        gl_FragColor[0] = color[0];
        gl_FragColor[1] = color[1];
        gl_FragColor[2] = color[2] *factor;
        gl_FragColor[3] = alpha*color[3]; /* Not sure alpha makes sense in xyL mode */
    }
}
