classdef messenger < handle
    % Class to handle communication between the local computer that runs
    % the experiment and a remote computer.
    % In the simplest, default form, the remote computer passively receives
    % the messages that are generated by writeToFeed commands issued by stimuli and plugins.
    % These are messages that are intended for the experimenter and are
    % written to the command line.
    % 
    % To avoid interfering witht the experiment itself, these messages can
    % be cached and written out in the intertrial interval (localCache =
    % true), and they can also be sent to a different computer by
    % specifying host name and starting a messenger there. 
    %
    % This makes it possible to run the experiment on a single
    % monitor machine (which improves timing of PTB) and still get
    % online information on the progression of the experiment.
    %
    % Usage:
    % If I want to receive messages on a remote computer called 
    % 'moustache.vision.rutgers.edu' I add this to the experiment file:
    % 
    % c.messenger.host = 'moustache.vision.rutgers.edu'
    % 
    % And, on moustache.vision.rutgers.edu, I start Matlab and then run 
    % neurostim.messenger(true);
    %  This will start a local "server" that gets its messages from the
    %  Neurostim application ("client").
    %
    % Messenger can also do two-way communication, which is useful to
    % generate closed-loop experiments. In that case the remote computer
    % could be running some data analysis and send back updates to the
    % parameters of the experiment.
    %
    % BK March 2019.
    
    properties (Constant)
        EMPTYCACHE = struct('style',cell(1000,1),'formatSpecs',cell(1000,1),'msg',cell(1000,1),'plg',cell(1000,1),'trialTime',cell(1000,1),'trial',cell(1000,1));
    end
    
    properties (SetAccess=public, GetAccess=public)
        %% Properties of the remote server and local client
        host@char=''; % The remote server to connect to  (empty means no remote server)
        port@double =1024;
        timerPeriod@double = 2; % the remote host will check for new inputs every 2 seconds.
        autoRestart = true; % TCP connections are closed at the end of an experiment, but with this set to true, the remote will automatically start waiting for the next experiment.
        
        outputBufferSize@double = 100000; % bytes
        inputBufferSize@double = 100000; % bytes
        timeout@double = 1; % seconds      
        
        
        %% Cache
        localCache@logical = false;    % Write out only after the trial ends [false]
        cache = neurostim.messenger.EMPTYCACHE;  % initialize empty
        cacheCntr@double =0;
        echo@logical = true;            % Even when logging remotely, generate local echo too.
        
        useColor@logical = true;        % Use cprintf's color functionality
        
        cic; % Handle to the parent cic
        remoteFunction; % Handle to a function that does extra processing on the remote host.
        
    end
    properties (SetAccess=private, GetAccess=public)
        isRemote@logical = false;
        tcp; % Leave this untyped so that someone without the TCPIP toolbox can use the object locally.
    end
    
    properties (Dependent)
        hasRemote;
    end
    
    methods
        function v=get.hasRemote(o)
            v = ~isempty(o.host);
        end
    end
    
    
    methods
        function o= messenger(remote)
            o = o@handle;            
            if nargin<1
                remote =false;
            end
            if remote
                o.isRemote = true;
                o.port = 1024;
                o.host = '0.0.0.0';
                setupRemote(o);
            end
        end
        function close(o)
            if o.hasRemote
                data = getByteStreamFromArray('CLOSE');
                binblockwrite(o.tcp,[double('#') 1 numel(data) data],'uint8');
            end
        end
        function disp(o)
            if o.isRemote
                disp(['Remote Messenger for ' o.tcp.RemoteHost]);
            elseif o.hasRemote
                disp(['Local messenger connected to ' o.host]);
            else
                disp('Local messenger');
            end
        end
        
        function feed(o,inTrial,style,thisTrial,thisTrialTime,msg,plg)
            % This function is called from plugin.writeToFeed
            if inTrial && (o.localCache || o.hasRemote)
                % Cache the info for later printing to the command line.
                % When using a remote host, feeds must be cached.
                o.cacheCntr= o.cacheCntr+1;
                o.cache(o.cacheCntr).style = style;
                o.cache(o.cacheCntr).inTrial = inTrial;                
                o.cache(o.cacheCntr).msg = msg;
                o.cache(o.cacheCntr).plg= plg;
                o.cache(o.cacheCntr).trialTime = thisTrialTime;
                o.cache(o.cacheCntr).trial = thisTrial;
            else
                % Print immediately to the local command line
                print(o,inTrial,style,thisTrial,thisTrialTime,msg,plg);
            end
        end
   
        function sendCommand(o,update)
            if ~isstruct(update);error('Update commands must be structs');end
            if (o.isRemote && o.hasRemote)
                % Send this update struct to the local side.
                % update should be a struct where each field is a plugin 
                % update.gabor.orientation = 0 (to update the gabor
                % plugin's orientation parameter)                
                data = getByteStreamFromArray(update);
                binblockwrite(o.tcp,[double('#') 1 numel(data) data],'uint8');
            end
            
        end
        
        function printCache(o)
            if (~o.isRemote && o.hasRemote)
                % Send to remote messenger
                data = getByteStreamFromArray(o.cache(1:o.cacheCntr));
                binblockwrite(o.tcp,[double('#') 1 numel(data) data],'uint8');
            end
            
            if o.echo
                % Also show locally
                [~,ix] = sortrows([[o.cache.trial]' [o.cache.trialTime]']);
                for i=ix'
                    print(o,o.cache(i).inTrial,o.cache(i).style,o.cache(i).trial,o.cache(i).trialTime,o.cache(i).msg,o.cache(i).plg);
                end
                o.cache =neurostim.messenger.EMPTYCACHE;
                o.cacheCntr =0;
            end
        end
        
        
        function setupRemote(o)
            % Start a server on the remote to receive messages from the local client.
            o.checkToolbox;
            [~,serverName] =system('hostname');
            serverName = deblank(serverName);
            o.tcp = tcpip(o.host,o.port,'NetworkRole','Server',...
                'Name',['NS@' serverName],...
                'OutputBufferSize',o.outputBufferSize,...
                'InputBufferSize',o.inputBufferSize,...
                'Terminator','LF',...
                'Timeout',o.timeout);
            o.tcp.BytesAvailableFcn = @o.updateRemote;
            o.tcp.BytesAvailableFcnMode = 'terminator';
            o.tcp.ReadAsyncMode=  'continuous';
            o.echo = true; % Server always echos
            runRemote(o);
        end
        
        function runRemote(o)
            tmr = timerfind('Name','Logger');
            if ~isempty(tmr)
                stop(tmr);
                delete(tmr);
            end
            if strcmpi(o.host,'0.0.0.0')
                hstStr = 'any host';
            else
                hstStr = o.host;
            end
            disp(['Waiting for a messenger connection on port ' num2str(o.port) ' from ' hstStr ]);
            fopen(o.tcp); % Busy wait until the client connects
            if strcmpi(o.tcp.Status,'Open')
                disp(['Connected to ' o.tcp.RemoteHost]);
            end
            disp('Starting timer to read incoming feeds')
            tmr = timer('BusyMode','drop','ExecutionMode','FixedRate','Period',o.timerPeriod,'TimerFcn',@o.updateRemote,'Name','Logger');
            start(tmr);
            disp(['Timer running every '  num2str(o.timerPeriod) 's']);
        end
        
        % The timer running on the remote host calls this to process the incoming
        % data.
        function updateRemote(o,tmr,event) %#ok<INUSD>
            if ~o.isRemote; return;end 
            if o.tcp.BytesAvailable >0
                bytes = binblockread(o.tcp,'uint8'); % Retrieve bytestream encoded message
                data= getArrayFromByteStream(uint8(bytes(4:end))); % Conver to Matlab vars.
                if ischar(data)
                    switch (data)
                        case 'CLOSE'
                            fclose(o.tcp);
                            if o.autoRestart
                                runRemote(o);
                            end
                        otherwise
                            disp(data)
                    end
                elseif iscell(data)
                    % This was a call from the client sending a single print line (see o.print)
                    % This is not recommended - too much reading/writing.
                    print(o,data{:});
                elseif isstruct(data)
                    % This should be the cache that was sent from the
                    % client.
                    o.cache =data; % Store it on the host
                    printCache(o); % Print it to the command line
                else
                    disp('Received unknown data object from the experiment computer')
                    data
                end                
            end
            
            if ~isempty(o.remoteFunction)
                % Extra processing on the remote side.
                update = o.remoteFunction(o); % Call the function the user provided with the (remote) messenger object
                if isstruct(update) 
                    % If this is a command then send it to the local side.
                     sendCommand(o,update);
                end
            end
            
        end
        
        
        function updateLocal(o) 
            % Communication from the remote to the experiment computer.
            % Should only be run by the experiment computer (as it requires
            % access to CIC, which only the client has)
            % Typically added to afterTrial with cic.addScript
            if o.isRemote; return;end
            if ~o.hasRemote; error('To use updateLocal you have to specify a remote host');end           
            if o.tcp.BytesAvailable >0
                bytes = binblockread(o.tcp,'uint8'); % Retrieve bytestream encoded message
                data= getArrayFromByteStream(uint8(bytes(4:end))); % Conver to Matlab vars.
                if ischar(data)
                   disp(data)                   
                elseif isstruct(data)
                    % This should be plugin.property=value (e.g.
                    % data.gabor.contrast = 0.5  will set the gabor plugins
                    % contrast to 0.5
                    pluginNames =fieldnames(data);
                    for i=1:numel(pluginNames)
                        propertyNames= fieldnames(data.(pluginNames{i}));
                        for j=1:numel(propertyNames)
                            o.cic.(pluginNames{i}).(propertyNames{j}) = data.(pluginNames{i}).(propertyNames{j});
                        end
                    end
                else
                    disp('Received unknown data object from remote computer')
                    data
                end
            end
        end
               
        
        
        function setupLocal(o,c)
            % If a host has been specified, this function will try to
            % connect to it. (The Matlab instance running the experiment is
            % the "client").
            % Unlike the remote end, this does not setup a timer. If
            % updateLocal is to be called, it can be added to a beforeTrial
            % or afterTrial update with c.addScript in the experiment file.
            o.cic=c;
            if ~isempty(o.host)
                o.checkToolbox;
                [~,clientName] =system('hostname');
                clientName = deblank(clientName);
                o.tcp = tcpip(o.host,o.port,'NetworkRole','client',...
                    'name',['NS@' clientName],...
                    'OutputBufferSize',o.outputBufferSize,...
                    'InputBufferSize',o.inputBufferSize,...
                    'Terminator','LF',...
                    'Timeout',o.timeout,...
                    'ByteOrder','littleEndian');
                    answer = input(['Is the remote messenger running on ' o.host ':' num2str(o.port) ' ( Use: neurostim.messenger(true);) [Y/n]'],'s');
                    if isempty(answer)
                        answer = 'Y';
                    end
                    connected=false;
                    if strcmpi(answer,'Y')
                        try
                           fopen(o.tcp); % Busy wait until connected.                           
                        catch 
                            
                        end
                        if strcmpi(o.tcp.Status,'Open')
                            connected =true;
                            disp(['Connected to ' o.tcp.RemoteHost ':' num2str(o.tcp.RemotePort)]);
                        else                            
                            disp(['Failed to connect to the messenger app (' o.host ':' num2str(o.port) '). Is it running? ']);
                        end
                    end
                    if ~connected
                        answer = input('Continue without remote messenger? (Y/n)','s');
                        if strcmpi(answer,'N')
                           error('No remote messenger');
                        else
                            o.host = ''; % No remote host
                        end
                    end                        
            end
        end
        
        
        function print(o,inTrial,style,thisTrial,thisTrialTime,msg,plg)
            % Prints one or more lines of information to the command line            .
            if inTrial
                phaseStr = '';
            else
                phaseStr = '(ITI)';
            end
            if ~o.useColor
                style = 'NOSTYLE';
            end
            if iscell(msg)
                % multi line message
                maxChars = max(cellfun(@numel,msg));
                neurostim.utils.cprintf(style,'TR: %d: (T: %.0f %s) %s \n',thisTrial,thisTrialTime,phaseStr,plg); 
                neurostim.utils.cprintf(style,'\t%s\n',repmat('-',[1 maxChars]));
                for i=1:numel(msg)
                    neurostim.utils.cprintf(style,'\t %s\n',msg{i}); % These are the message lines
                end
                neurostim.utils.cprintf(style,'\t%s\n',repmat('-',[1 maxChars]));
            else
                % single line
                neurostim.utils.cprintf(style,'TR: %d (T: %.0f %s): %s - %s \n',thisTrial,thisTrialTime,phaseStr,plg,msg);
            end
        end
        
        function checkToolbox(~)
            f = which('tcpip');
            if isempty(f)
                error('neurostim.messenger requires the tcpip command (part of the Instrument Control Toolbox). Install it to use messenger across the network (or set c.messenger.host =''''  to use local messaged only.');
            end
        end
        
    end
    
    
    
end